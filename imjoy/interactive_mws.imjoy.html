<docs lang = "markdown">
[TODO: write documentation for this plugin.]
</docs>

<config lang = "json">
{
    "name": "MWS Interactive",
    "type": "native-python",
    "version": "0.1.0",
    "description": "[TODO: describe this plugin with one sentence.]",
    "tags": [],
    "ui": "",
    "cover": "",
    "inputs": null,
    "outputs": null,
    "flags": [],
    "icon": "extension",
    "api_version": "0.1.5",
    "env": "conda create -n mws-cpu python=3.7",
    "requirements": ["conda: -c cpape -c conda-forge h5py affogato==0.1.3 scikit-image vigra pillow"],
    "dependencies": []
}
</config>


<script lang = "python">
from imjoy import api
import base64
from affogato.segmentation import InteractiveMWS
#from affogato.segmentation.interactive_mws import parse_geojson
from skimage.io import imread, imsave
from PIL import Image
import numpy as np
from time import sleep
# import torch
import io
import asyncio
import concurrent
import json

def parse_geojson(geojson, shape):
    """ Parse input dicts in geo json format
        and return input for ``InteractiveMWS.update_seeds``
    """
    # we always expect to get a 'FeatureCollection'
    if geojson.get("type", "") != "FeatureCollection":
        raise ValueError("Expect to get a geojson with FeatureCollection")

    seed_coordinates = {}
    annotations = geojson['features']

    # iterate over the annotations and get the coords
    for annotation in annotations:
        # get the seed id from the properties.
        # TODO how is the key called in Imjoy?
        seed_name = annotation['properties']['name']
        coords = annotation['geometry']['coordinates']
        geo_type = annotation['geometry']['type']
        if geo_type == 'Point':
            coords = [coords]

        # TODO we need some convention for mapping the seed name to an id
        if seed_name in seed_coordinates:
            print("parser", seed_name, " in coords ... extending by ", coords)
            seed_coordinates[seed_name].extend(coords)
        else:
            print("parser", seed_name, " set new ", coords)
            seed_coordinates[seed_name] = coords

    seed_coordinates = {int(seed_id): tuple(np.array([coord[1-i] if i == 1 else shape[1 - i] - coord[1 - i] for coord in coords], dtype='uint64')
                                       for i in range(2))
                        for seed_id, coords in seed_coordinates.items()}



    return seed_coordinates



class ImJoyPlugin():

    def setup(self):
        api.log('initialized')

    def load_image(self, file):
        return imread(file)

    def load_model(self, model_file):
        # TODO: fix this
        return torch.load(model_file)

    def predict(self, model, img):

        # with torch.no_grad():
        #     batch = img[None].astype(np.float32)

        #     # whiten
        #     batch -= batch.mean()
        #     batch /= batch.std()
        #     batch = torch.from_numpy(batch)

        #     affs = model(batch)[0].cpu().numpy()

        # return affs

        # TODO: use the actual model

        import h5py
        with h5py.File("/home/swolf/local/data/hackathon2019/slice0.h5", "r") as h5file:
            prediction = h5file["data"][:]

        return prediction

    def update_segmentation(self, interactive, coords):

        print('update seeds')
        parsed_coords = parse_geojson(coords, interactive.shape)
        print("parsed coords", parsed_coords)
        interactive.clear_seeds()
        interactive.update_seeds(parsed_coords)
        print('run mws')
        segmentation = interactive()
        print('mws done')

        segmentation = np.stack(((segmentation % 255).astype(np.uint8),
                                ((segmentation / 255) % 255).astype(np.uint8),
                                ((segmentation / 255**2)% 255).astype(np.uint8)), axis=-1)

        blend_image = segmentation
        print('uniques' + str(np.unique(blend_image)))
        print("blend_shape ", blend_image.shape)
        name_plot = "/home/swolf/pictures/tmp.png"
        imsave(name_plot, blend_image)

        with open(name_plot, 'rb') as f:
            result = base64.b64encode(f.read()).decode('ascii')
        imgurl = 'data:image/png;base64,' + result
        return {'url': imgurl,
                'w': segmentation.shape[0],
                'h': segmentation.shape[1]}

    def init_mws(self):
        
        model = None
        img = None
        affs = self.predict(model, img)[..., :512, :512]
        eps = 0.01
        affs *= (1 - eps)
        affs += eps * np.random.rand(*affs.shape)

        image_shape = affs.shape[1:]
        number_of_nodes = affs.shape[-1] * affs.shape[-2]
        offsets = [[-1, 0],
                   [0, -1],
                   [-3, 0],
                   [0, -3],
                   [-9, 0],
                   [0, -9],
                   [-27, 0],
                   [0, -27]]

        return InteractiveMWS(affs,
                                     offsets,
                                     n_attractive_channels=2,
                                     strides=[8, 8],
                                     randomize_strides=True)

        


    async def run(self, ctx):
        print("SEHR VIEL TEXT")
        ann_window = await api.createWindow(type="MWSAnnotator", name="thiswindow", sandbox="allow-same-origin allow-scripts", data={})
        print("show_image ")

        loop = asyncio.get_event_loop()

        seed_name_map = {}
        max_label = 1
        centered = False


        with concurrent.futures.ThreadPoolExecutor() as pool:

            interactive = await loop.run_in_executor(pool, self.init_mws)

            counter = 0
            while True:
                counter += 1
                dirty = await ann_window.is_dirty()
                if dirty:
                    print("found dirty")
                    coords = await ann_window.getAnnotation()

                    # create names for coord objects

                    for c_dict in coords['features']:
                        label = c_dict['properties']['label']
                        if label not in seed_name_map:
                            seed_name_map[label] = max_label
                            max_label += 1

                        c_dict['properties']["name"] = str(seed_name_map[label])

                    print("coords ", coords)

                    result = await loop.run_in_executor(
                        pool, self.update_segmentation, interactive, coords)
                    
                    await ann_window.displayimage(result)

                    if not centered:
                        await ann_window.centeronimage(result)
                        centered = True
                    
                    await ann_window.set_clean()
                await asyncio.sleep(1)

        print('custom thread pool', result)

api.export(ImJoyPlugin())
</script>