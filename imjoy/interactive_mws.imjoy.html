<docs lang = "markdown">
[TODO: write documentation for this plugin.]
</docs>

<config lang = "json">
{
    "name": "MWS Interactive",
    "type": "native-python",
    "version": "0.1.0",
    "description": "[TODO: describe this plugin with one sentence.]",
    "tags": [],
    "ui": "",
    "cover": "",
    "inputs": null,
    "outputs": null,
    "flags": [],
    "icon": "extension",
    "api_version": "0.1.5",
    "env": "conda create -n mws-cpu python=3.7",
    "requirements": ["conda: -c cpape -c conda-forge h5py affogato==0.1.3 scikit-image vigra pillow"],
    "dependencies": []
}
</config>


<script lang = "python">
from imjoy import api
import base64
from affogato.segmentation import InteractiveMWS
#from affogato.segmentation.interactive_mws import parse_geojson
from skimage.io import imread, imsave
from PIL import Image
import numpy as np
from time import sleep
# import torch
import io
import asyncio
import concurrent
import json

def parse_geojson(geojson, shape):
    """ Parse input dicts in geo json format
        and return input for ``InteractiveMWS.update_seeds``
    """
    # we always expect to get a 'FeatureCollection'
    if geojson.get("type", "") != "FeatureCollection":
        raise ValueError("Expect to get a geojson with FeatureCollection")

    seed_coordinates = {}
    annotations = geojson['features']

    # iterate over the annotations and get the coords
    for annotation in annotations:
        # get the seed id from the properties.
        # TODO how is the key called in Imjoy?
        seed_name = annotation['properties']['name']
        coords = annotation['geometry']['coordinates']
        geo_type = annotation['geometry']['type']
        if geo_type == 'Point':
            coords = [coords]

        # TODO we need some convention for mapping the seed name to an id
        if seed_name in seed_coordinates:
            print("parser", seed_name, " in coords ... extending by ", coords)
            seed_coordinates[seed_name].extend(coords)
        else:
            print("parser", seed_name, " set new ", coords)
            seed_coordinates[seed_name] = coords

    seed_coordinates = {int(seed_id): tuple(np.array([coord[1-i] if i == 1 else shape[1 - i] - coord[1 - i] for coord in coords], dtype='uint64')
                                       for i in range(2))
                        for seed_id, coords in seed_coordinates.items()}



    return seed_coordinates



class ImJoyPlugin():

    def setup(self):
        api.log('initialized')

    def load_image(self, file):
        return imread(file)

    def load_model(self, model_file):
        # TODO: fix this
        return torch.load(model_file)

    def predict(self, model, img):

        # with torch.no_grad():
        #     batch = img[None].astype(np.float32)

        #     # whiten
        #     batch -= batch.mean()
        #     batch /= batch.std()
        #     batch = torch.from_numpy(batch)

        #     affs = model(batch)[0].cpu().numpy()

        # return affs

        # TODO: use the actual model

        import h5py
        # aff_path = "/home/swolf/local/data/hackathon2019/slice0.h5"
        aff_path = "/home/pape/Work/data/ilastik/mulastik/data/slice0.h5" 
        with h5py.File(aff_path, "r") as h5file:
            prediction = h5file["data"][:]

        return prediction

    def update_segmentation(self, interactive, coords):

        print('update seeds')
        parsed_coords = parse_geojson(coords, interactive.shape)
        print("parsed coords", parsed_coords)
        interactive.clear_seeds()
        interactive.update_seeds(parsed_coords)
        print('run mws')
        segmentation = interactive()
        print('mws done')

        return segmentation


    async def blend(self, img, seg, seed_color_map):

        seg_color = np.stack(((seg % 255).astype(np.uint8),
                                ((seg / 255) % 255).astype(np.uint8),
                                ((seg / 255**2)% 255).astype(np.uint8)), axis=-1)

        for l in seed_color_map:
            mask = seg==l
            for c in range(3):
                seg_color[..., c][mask] = seed_color_map[l][c]

        img = np.repeat(img[:512, :512, None], 3, axis=-1)

        #bending
        blend = 0.6 * seg_color + 0.4 * img

        return blend

    async def displayimage(self, ann_window, img):
        # name_plot = "/home/swolf/pictures/tmp.png"
        name_plot = "/home/pape/Pictures/tmp.png"
        imsave(name_plot, img)

        with open(name_plot, 'rb') as f:
            result = base64.b64encode(f.read()).decode('ascii')
        imgurl = 'data:image/png;base64,' + result
        ann_window.displayimage({'url': imgurl,
                'w': img.shape[0],
                'h': img.shape[1]})


    def init_mws(self):
        
        model = None
        img = None
        affs = self.predict(model, img)[..., :512, :512]
        eps = 0.01
        affs *= (1 - eps)
        affs += eps * np.random.rand(*affs.shape)

        image_shape = affs.shape[1:]
        number_of_nodes = affs.shape[-1] * affs.shape[-2]
        offsets = [[-1, 0],
                   [0, -1],
                   [-3, 0],
                   [0, -3],
                   [-9, 0],
                   [0, -9],
                   [-27, 0],
                   [0, -27]]

        return InteractiveMWS(affs,
                              offsets,
                              n_attractive_channels=2,
                              strides=[8, 8],
                              randomize_strides=True)

    def init_raw(self):
        # raw_path = "/home/swolf/local/data/hackathon2019/slice0.png"
        raw_path = "/home/pape/Work/data/ilastik/mulastik/data/slice0.png"
        img = imread(raw_path)
        return img
        
    async def run(self, ctx):
        ann_window = await api.createWindow(type="MWSAnnotator", name="thiswindow", sandbox="allow-same-origin allow-scripts", data={})
        print("show_image ")

        loop = asyncio.get_event_loop()

        seed_name_map = {}
        seed_color_map = {}
        max_label = 1
        centered = False

        with concurrent.futures.ThreadPoolExecutor() as pool:

            interactive = await loop.run_in_executor(pool, self.init_mws)
            img = await loop.run_in_executor(pool, self.init_raw)

            counter = 0
            while True:
                counter += 1
                dirty = await ann_window.is_dirty()
                if dirty:
                    print("found dirty")
                    coords = await ann_window.getAnnotation()

                    # create names for coord objects

                    for c_dict in coords['features']:
                        label = c_dict['properties']['label']
                        if label not in seed_name_map:
                            seed_name_map[label] = max_label
                            seed_color_map[max_label] = 128 + 128 * np.random.rand(3)
                            max_label += 1

                        c_dict['properties']["name"] = str(seed_name_map[label])

                    print("coords ", coords)

                    segmentation = await loop.run_in_executor(
                        pool, self.update_segmentation, interactive, coords)

                    # alpha blending
                    blend = await self.blend(img, segmentation, seed_color_map)
                    await self.displayimage(ann_window, blend)

                    if not centered:
                        await ann_window.centeronimage({'w': blend.shape[0],
                                                        'h': blend.shape[1]})
                        centered = True

                    await ann_window.set_clean()
                await asyncio.sleep(1)

        print('custom thread pool', result)

api.export(ImJoyPlugin())
</script>
